---
title: "GBI6 - BIOINFORMÁTICA"
subtitle: "EXAMEN FINAL"
author: 'Pacheco Ibeth'
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: espresso
    theme: paper
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: no
      smooth_scroll: yes
---

![](./img/ikiam.png)

**Bienvenidos al examen final de GBI6 - Bioinformática.**

# CONTENIDO DE LA EVALUACIÓN

Los contenidos de esta evaluación corresponden a los temas de R revisados en el curso:

-   Tipos de datos

-   Instalación y uso de librerías. 

-   Estructuras de control

-   Funciones

-   Manipulación de datos

-   Estadística básica

-   Visualización de datos

# INDICACIONES GENERALES

Esta permitido consultar todo material disponible: diapositivas, google...Sin embargo **NO** esta permitido consultar a sus colegas.

Ustedes estan utilizando el R Markdown. Las instruciones son:

-   Creen una carpeta en su computador con el nombre "GBI6_ExamenFinal" donde guarden este cuaderno .Rmd. 

- Cree un subdirectorio de nombre "data" donde guarde la data que van a utilizar.

- Cree un subdirectorio de nombre "results" donde guarde la tablas y figuras generadas del análisis.

-   Definan a esa carpeta como su directorio de trabajo.

-   Arriba, **solamente** donde dice "author", deben llenar sus nombres.

-   Los codigos deben ser escritos dentro de las cajas que inician y terminan con \`\`\` o dentro de las cajas indicadas abajo de las preguntas.

-   Al final del examen deben utilizar el comando "Knit" para generar un archivo .html

-   Es recomendable crear una copia de este script guía.

-   Genere controles de la versión para cada una de las preguntas con la leyenda "Nombre Apellido, resuelve el ejercicio XX". 

- Copie y peque la dirección de su repositorio de GitHub en la actividad **"ExamenFinal"**.

-   Asegúrese de responder explícitamente cada una de las preguntas.

Para comprender la data de esta evaluación se requiere conocer el significado de algunos acrónimos de los tipos de cancer como indica el [Broad Institute Cancer Names](https://gdac.broadinstitute.org/). Asimismo revise la información de ayuda para ```expresionsTCGA```. La data contiene las columnas: 

- **bcr_patient_barcode**: es el identificador del paciente. 

- **dataset**: es el identificador del tipo de cancer del paciente. 

- **resto de columnas**: nivees de expresión de los diferentes mRNA de los genes que están como nombre de columna (para este análisis se han seleccionado solamente 7 de ellos). 

# PREGUNTAS
## **Pregunta 1: MANIPULACIÓN DE DATOS [4 PUNTOS]**

### [0.5 PUNTOS] 1.1 Defina su directorio de trabajo. 
```{r wd}
setwd("C:/Users/usuario/Desktop/ikiam_2022/sexto/bioinformatica/")
```

### [0.5 PUNTOS] 1.2. Cargue la data "mRNA_expr.csv"
```{r data}
df <- "cargue la data"
library(readr)
df <- read_csv("data/mRNA_expr.csv") 

```

### [1 PUNTO] 1.3 Cree una función de nombre ```long_df``` para transformar la data ```df``` de la forma wide a long.

```{r funcion_long}
# Escriba aquí la función long_df
## Función long_df. realiza un reordenamiento de datos de wider a longer. 
library(tidyr)
library(dplyr)
long_df <- function(df) {
  long_df <- gather(df, gen, expresion_level, GATA3, PTEN, XBP1, ESR1, MUC1, FN1, GAPDH, factor_key=TRUE)
  long_df1 <- select(long_df, -bcr_patient_barcode)
  return (long_df1)
}

```


### [1 PUNTO] Genere la data ```df_long``` utilizandola función ```long_df```. 
La tabla resultante tendrá tres columnas: ```dataset, gen, expresion_level```.  
```{r df_long}
# Genere la data df_long 
df_long <- long_df(df) 

```

### [0.5 PUNTOS] 1.5 A partir de la data ```df_long```, genere un **Descriptive table** (librería ```sjPlot```) y guárdelo en el subdirectorio "result"  con el nombre **mRNA_expr_summary.doc** (previamente debe seleccionar las celdas adecuadas con funciones de la librería ```dplyr``` en conjunto con el operador ```%>%```). 
```{r desc_table}
# Escriba el código para crear el Descriptive table 

## Crea un data frame llamado LUSC_df que contiene los datos del cancer de pulmon. Posteriormente, creamos un data frame denominado desc_table, aqui cambiamos el ordenamiento de los datos de longer a wider. Finalmente creamos un resumen de los datos de estadistica descriptivas y guardamos la tabla con la función tab_df()

library(sjPlot)
library(sjmisc)
#Lung squamous cell carcinoma
LUSC_df <- df_long %>% filter(dataset == "LUSC") %>% select(2:3) 
desc_table <- LUSC_df %>% group_by(gen) %>% mutate(row = row_number()) %>%
  tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
  select(-row)
descr(desc_table) %>% tab_df(title = "Estadistica descriptiva del cancer de pulmen LUSC", file = "results/mRNA_expr_summary.doc") 

```

### [0.5 PUNTOS] 1.6 Interprete los resultados de la tabla resultante de la sección 1.5. 


```{tex}
# La tabla presenta estadistica descriptiva del data frame desc_Table. En la columna se observa que existen 154 muestras de cancer de pulmon. La media entre los genes difiere y presenta valores positivos y negativos. Finalmente presenta valores de error estandar menores a 0.10 indicando una estimacion precisa de la media. 

```



## **Pregunta 2 VISUALIZACION DE DATOS  [5 PUNTOS]**

Para esta pregunta tiene que utilizar la data ```df_long```. 

### [1 PUNTO] 2.1 Cree la funcion ```tcga_boxplots``` para visualizar boxplots y jitterplots. El único parámetro de la función es ```dataset```. La función debe crear un boxplot de los niveles de expresión para cada gen.

```{r}
# Escriba el código para crear la función tcga_boxplots

library(ggplot2) 
## creamos la función tcga_boxplots. Parametro de input un data frame y output un grafico con el nivel de expresión de cada gen
tcga_boxplots <- function(dataset) {
  return(ggplot (dataset, aes(x = gen, y = expresion_level, col = gen)) + labs(x="Gen", y = "Nivel de expresion") + geom_boxplot())
}
```

### [0.5 PUNTOS] 2.2 Utilizando la función ```lapply()``` genera la lista ```cancertype_boxplots``` con las gráficas para cada tipo de cancer (cada tipo de dataset). 
```{r list_boxplots}
# Escriba el código para generar la lista. 
## creamos una lista de data frame utilizando la función filter para crear nuevos data frames por los 6 tipos de canceres. 
list_boxplots <- list(
  BRCA <- filter(df_long, dataset == "BRCA"),
  OV <- filter(df_long, dataset == "OV"),
  LUSC <- filter(df_long, dataset == "LUSC"),
  KIPAN <- filter(df_long, dataset == "KIPAN"),
  KIRP <- filter(df_long, dataset == "KIRP"),
  UCEC <- filter(df_long, dataset == "UCEC")
)

## creamos la lista cancertype_boxplots que contiene los niveles de expresion de los tipos de canceres 
cancertype_boxplots = lapply(list_boxplots, function(x) {ggplot(x, aes(dataset, expresion_level, col = dataset)) + geom_boxplot() + labs( y = "Nivel de expresión")})

```

### [0.5 PUNTOS] 2.3 Guarde en el subdirectorio ```result``` el tercer plot de la lista ```cancertype_boxplots``` con el nombre ```boxplot3.png```. La definición de a figura debe ser de 300dpi. 
```{r boxplot3}
# Escriba el código para guardar la tercera figura de la lista. 
cancertype_boxplots[3]
ggsave("results/boxplot3.png", width = 6, height = 8, dpi = 300)


```


### [1 PUNTO] 2.4 Escriba la función ```reg_gen_expression```, con el parámetro ```gen```. En este caso la función visualizará una gráfica de nube de puntos (geom_point) y una regresión por tipo de "dataset". La gráfica será de comparación de gen1 con gen2; por ejemplo en el eje "x" ```GATA3``` y en el eje "y"" ```FN1```.  

```{r reg_gen_exp}
# Escriba aquí su función reg_gen_expression

type_cancer <- list(
  BRCA <- filter(df_long, dataset == "BRCA"),
  OV <- filter(df_long, dataset == "OV"),
  LUSC <- filter(df_long, dataset == "LUSC"),
  KIPAN <- filter(df_long, dataset == "KIPAN"),
  KIRP <- filter(df_long, dataset == "KIRP"),
  UCEC <- filter(df_long, dataset == "UCEC")
)
## creamos la lista plots_cancer. La lista transforma las data set longer a wider  
plots_cancer <- list (  
  BRCA_1 <- BRCA %>% group_by(gen) %>% mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
    select(-row),
  OV_1 <- OV %>% group_by(gen) %>% mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
    select(-row),
  LUSC_1 <- LUSC %>% group_by(gen) %>% mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
    select(-row),
  KIPAN_1 <- KIPAN %>% group_by(gen) %>% mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
    select(-row),
  KIRP_1 <- KIRP %>% group_by(gen) %>% mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
    select(-row),
  UCEC_1 <- UCEC %>% group_by(gen) %>% mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = gen, values_from = expresion_level) %>%
    select(-row)
)

## La función reg_gen_expression(). El parametro de entrada es tipo string y se puede elegir entre los siete genes de estudio 
## Posteriormente el gen elegido ploteara las 6 combinaciones posibles con el resto de genes y guardara en la lista  

reg_gen_expression <- function (gen) {
  ## enunciamos la condicional if para deliminar el gen de estudio y crear posteriormente los graficos 
  if (gen == "GATA3"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(GATA3, PTEN)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GATA3, XBP1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GATA3, ESR1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GATA3, MUC1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GATA3, FN1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GATA3, GAPDH)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
  else if (gen == "PTEN"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(PTEN, GATA3)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(PTEN, XBP1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(PTEN, ESR1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(PTEN, MUC1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(PTEN, FN1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(PTEN, GAPDH)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
  else if (gen == "XBP1"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(XBP1, GATA3)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(XBP1, PTEN)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(XBP1, ESR1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(XBP1, MUC1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(XBP1, FN1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(XBP1, GAPDH)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
  else if (gen == "ESR1"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(ESR1, GATA3)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(ESR1, PTEN)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(ESR1, XBP1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(ESR1, MUC1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(ESR1, FN1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(ESR1, GAPDH)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
  else if (gen == "MUC1"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(MUC1, GATA3)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(MUC1, PTEN)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(MUC1, XBP1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(MUC1, ESR1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(MUC1, FN1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(MUC1, GAPDH)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
  else if (gen == "FN1"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(FN1, GATA3)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(FN1, PTEN)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(FN1, XBP1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(FN1, ESR1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(FN1, MUC1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(FN1, GAPDH)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
  else if (gen == "GAPDH"){
    total <- list (
      lapply(plots_cancer, function(x) {ggplot(x, aes(GAPDH, GATA3)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GAPDH, PTEN)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GAPDH, XBP1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GAPDH, ESR1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GAPDH, MUC1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}), 
      lapply(plots_cancer, function(x) {ggplot(x, aes(GAPDH, FN1)) + 
          geom_point() + geom_smooth(method='lm', formula= y~x)}))
  }
}



```


### [0.5 PUNTOS] 2.5. Utilizando la función ```lapply()``` genera la lista ```reg_genplots``` con las gráficas para cada par de genes posibles. Recuerde que tiene 7 tipos de genes, se debe tener todas las combinaciones posibles por pares de genes (combinatoria sin repetición).
```{r list_regplots}
# Escriba el código para generar la lista. 
## En el caso de ejemplo se selecciono el gen GAPDH 
list_regplots <- reg_gen_expression("GAPDH")


```


### [0.5 PUNTOS] 2.6. Guarde en el subdirectorio ```result``` el onceavo plot de la lista ```reg_genplots``` con el nombre ```regresion11.pdf```. La definición de a figura debe ser de 300dpi. 
```{r reg11}
# Escriba el código para guardar el onceavo plot. 
list_regplots[[5]][[2]] 
# El primer valor es la combinacion de genes y el segundo indica el tipo de cancer
## [[1]][[1]], [[2]][[1]], [[3]][[1]], [[4]][[1]], [[5]][[1]], [[6]][[1]], [[1]][[2]], [[2]][[2]], [[3]][[2]], 
## [[4]][[2]], [[5]][[2]]. El 11vo grafico seria [[5]][[2]]. 
ggsave("results/regresion11.pdf", width = 8, height = 5, dpi = 400)

```


### [1 PUNTO] 2.7. Interprete los resultados de las figuras ```boxplot3.png``` y ```regresion11.pdf```.

```{tex}
# Esciba aquí su intepretación
## boxplot3 
## En el grafico muesta un diagaram de cajas y bigotes. Se puede observar que existen valores negativos positivos de expresioón, la mediana es 0.7 y el rango de expresión es de -5 a 3 indicando que los valores de cada gen difieren.  
## regresion11 
## Los valores de distribución muestran los resultados del gen GAPH en el eje x y MUC1 en el eje y. Los datos pertenecen al cancer de ovario. El grafico de puntos indica que los datos son variados y mediante analisis de regresión lineal se concluye que presentan una baja relación entre ellos. Finalmente la pendiente del grafico de regresión lineal tiende a ser negativo. 

```

## 3. CONTROL DE LA VERSIÓN [1 PUNTO]. Se verficará en ell repositorio de GitHub. 

